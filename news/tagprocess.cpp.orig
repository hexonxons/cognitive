/**
 * \file    tagprocess.cpp
 *
 * \brief   Определение функций, оперирующих со строками.
 */

#define _CRT_SECURE_NO_WARNINGS

#include "tagprocess.h"
#include <iostream>
#include <algorithm>
#include <stack>


using std::ios;
using std::make_pair;
using std::string;
using std::pair;
using std::set;
using std::stack;
<<<<<<< HEAD

//##################################  PUBLIC SECTION  #####################################
=======

//##################################  PUBLIC SECTION  ###################################

CNewsFinder::CNewsFinder(LPCSTR lpcszInFileName, UINT unMinSize, UINT unMinFreq):
    m_unMinSz(unMinSize),
    m_unAvgLen(0),
    m_unAvgFreq(0),
    m_unMinFreq(unMinFreq),
    m_unCurrFileDataPos(0),
    m_lLastError(0)
{
    std::fstream fileIn(lpcszInFileName, ios::in);
    m_fileData = std::string((std::istreambuf_iterator<char>(fileIn)), std::istreambuf_iterator<char>());
#ifdef _DEBUG
    plpszTagTable = new LPTSTR[1000];
    memset(plpszTagTable, 0, 1000 * sizeof(LPTSTR));
#endif
}

CNewsFinder::~CNewsFinder()
{
    if (m_unTableSize == 0)
        return;

    for (UINT i = 0; i < m_unTableSize; ++i)
        delete m_pTable[i];
    delete m_pTable;
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51

#ifdef _DEBUG
    delete(plpszTagTable);
#endif
}

VOID CNewsFinder::Init(vector<pair<string, string>> &remDoubleTag, vector<string> &remTag)
{
    if (m_lLastError == 1)
        return;

    m_lLastError = 1;

    UINT i = 0;
    UINT j = 0;
    int flag = 0;
    //LowerCase(&m_fileData);
    // M.A.P. плохая реализация преобразования в нижний регистр.  
    transform(m_fileData.begin(), m_fileData.end(), m_fileData.begin(), tolower);
    CTagDescription tag;
    tag = getNextTag();
    // 551 == <body>
    while (tag.nTagCode != 551)
    {
        tag = getNextTag();
    }

    tag = getNextTag();
    while (tag.nTagCode != -1)
    {
        m_mod.push_back(tag);
        tag = getNextTag();
    }
    
    removeTags(remTag);
    removeTags(remDoubleTag);

#ifdef _DEBUG
    dbgPrintData();
#endif

    // M.A.P. Не лучше ли выделять память одним куском?

    // Задаем размер таблицы
    m_unTableSize = m_mod.size();
    // Выделяем память на таблицу
    m_pTable = new bool *[m_unTableSize];

    if (m_pTable == NULL)
    {
        m_lLastError = -1;
        return;
    }

    for (i = 0; i < m_unTableSize; ++i)
    {
        m_pTable[i] = new bool[m_unTableSize];
        if (m_pTable[i] == NULL)
        {
            m_lLastError = -1;
            return;
        }
    }

    // Заполняем таблицу
    for (i = 0; i < m_unTableSize; ++i)
    {
        for (j = 0; j < m_unTableSize; ++j)
        {
            if (m_mod[i].nTagCode == m_mod[j].nTagCode)
            {
                m_pTable[i][j] = 1;
            }
            else
                m_pTable[i][j] = 0;
        }
    }
}

<<<<<<< HEAD
CNewsFinder::~CNewsFinder()
{
    if (m_tableSize == 0)
        return;

    for (unsigned int i = 0; i < m_tableSize; ++i)
        delete m_pTable[i];
    delete m_pTable;
}

void CNewsFinder::init(vector<pair<string, string>> &remDoubleTag, vector<string> &remTag)
{
    unsigned int i = 0;
    unsigned int j = 0;
    int flag = 0;
    // Ломает кодировку
    //LowerCase(&m_fileData);
    transform(m_fileData.begin(), m_fileData.end(), m_fileData.begin(), tolower);
    CTriple<CTag, CPair<int, int>, string> tagCode;
    while (tagCode.third != "<body>")
        tagCode = getNextTag();

    tagCode = getNextTag();
    while (tagCode.first.tag != -1)
    {
        if (tagCode.third == "</body>")
            break;
        m_alphabet.insert(CPair<CTag, string>(tagCode.first, tagCode.third));
        m_VtagFileData.push_back(CPair<CTag, CPair<int, int>>(tagCode.first, tagCode.second));
        tagCode = getNextTag();
=======
VOID CNewsFinder::GetPossibleRanges()
{
    UINT i = 0;
    // Читаем в table по диагоналям
    // diag - Номер диагонали
    // diag = 0 - главная диагональ, заполнена 
    UINT diag = 1;
    while(diag < m_unTableSize)
    {
        for (i = 0; i < m_unTableSize - diag; ++i)
        {
            if (m_pTable[i][i + diag] != 0)
            {
                vector<CTagDescription> range;
                int beg = i;
                while (i < m_unTableSize - diag && m_pTable[i][i + diag] != 0)
                {
                    range.push_back(m_mod[i]);
                    ++i;
                }
                // И проверяем возможность этой строчки(или её подстрок) быть началом или концом новости
                if (range.size() >= m_unMinSz)
                {
                    getTagSubs(range, beg + diag);
                    i += range.size() - 1;
                }
            }
        }
        // Читаем следующую диагональ
        ++diag;
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
    }
    // Вычисляем средние длины/частоты строк
    m_unAvgLen = m_unAvgLen / m_freq.size();
    m_unAvgFreq = m_unAvgFreq / m_freq.size();
}

VOID CNewsFinder::GetNewsRange()
{
    set <pair<vector<CTagDescription>, UINT>, ltstr>::iterator setIter;
    vector<pair<vector<CTagDescription>, UINT>>::iterator vectorIter;
    
<<<<<<< HEAD

    removeTags(remTag);
    removeTags(remDoubleTag);

    // Задаем размер таблицы
    m_tableSize = m_VtagFileData.size();
    // Выделяем память на таблицу
    m_pTable = new short *[m_tableSize];
    for (i = 0; i < m_tableSize; ++i)
        m_pTable[i] = new short[m_tableSize];

    // Заполняем таблицу
    for (i = 0; i < m_tableSize; ++i)
    {
        for (j = 0; j < m_tableSize; ++j)
        {
            if (m_VtagFileData[i].first.tag == m_VtagFileData[j].first.tag)
            {
                m_pTable[i][j] = 1;
            }
            else
                m_pTable[i][j] = 0;
        }
    }
}

void CNewsFinder::getPossibleRanges()
{
    unsigned int i = 0;
    // Читаем в table по диагоналям
    // diag - Номер диагонали
    // diag = 0 - главная диагональ, заполнена 
    unsigned int diag = 1;
    while(diag < m_tableSize)
    {
        for (i = 0; i < m_tableSize - diag; ++i)
        {
            if (m_pTable[i][i + diag] != 0)
            {
                vector<CPair<CTag, CPair<int, int>>> range;
                int beg = i;
                while (i < m_tableSize - diag && m_pTable[i][i + diag] != 0)
                {
                    range.push_back(m_VtagFileData[i]);
                    ++i;
                }
                // И проверяем возможность этой строчки(или её подстрок) быть началом или концом новости
                if (range.size() >= m_minSz && range.size() < 30)
                {
                    getTagSubs(range, beg + diag);
                    i += range.size() - 1;
                }
            }
        }
        // Читаем следующую диагональ
        ++diag;
    }
    // Вычисляем средние длины/частоты строк
    m_avgLen = m_avgLen / m_freq.size();
    m_avgFreq = m_avgFreq / m_freq.size();
}

void CNewsFinder::getNewsRange()
{
    set <CPair<vector<CPair<CTag, CPair<int, int>>>, unsigned int>, ltstr>::iterator setIter;
    vector<CPair<vector<CPair<CTag, CPair<int, int>>>, unsigned int>>::iterator vectorIter;
    
    for(setIter = m_freq.begin(); setIter != m_freq.end(); ++setIter)
    {
        if (setIter->second >= m_minFreq && 
            setIter->first.size() <= m_avgLen&&
            setIter->second <= m_avgFreq)
=======
    for(setIter = m_freq.begin(); setIter != m_freq.end(); ++setIter)
    {
        if (setIter->second >= m_unMinFreq && 
            setIter->first.size() <= m_unAvgLen &&
            setIter->second <= m_unAvgFreq)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
            possibleTags.push_back(*setIter);
    }
    // сортируем пары
    sort(possibleTags.begin(), possibleTags.end(), CNewsFinder::pred());


<<<<<<< HEAD
    unsigned int cnt = 1;
    while (cnt < possibleTags.size())
    {
        vector<CPair<CTag, CPair<int, int>>> temp = (possibleTags.end() - cnt)->first;
        vectorIter = possibleTags.end() - cnt - 1;
        for (unsigned int i = 0; i < possibleTags.size(); ++i)
=======
    UINT cnt = 1;
    while (cnt < possibleTags.size())
    {
        vector<CTagDescription> temp = (possibleTags.end() - cnt)->first;
        vectorIter = possibleTags.end() - cnt - 1;
        for (UINT i = 0; i < possibleTags.size(); ++i)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
        {
            while(vIsSubstr(temp, vectorIter->first) || vIsSubstr(vectorIter->first, temp))
            {
                possibleTags.erase(vectorIter);
                if (cnt == possibleTags.size())
                    break;            
                vectorIter = possibleTags.end() - cnt - 1;
            }
            ++cnt;
            if (cnt >= possibleTags.size())
                break;
            vectorIter = possibleTags.end() - cnt - 1;
        }
        ++cnt;
    }

    int newAvgFreq = 0;
<<<<<<< HEAD
    for (unsigned int i = 0; i < possibleTags.size(); ++i)
=======
    for (UINT i = 0; i < possibleTags.size(); ++i)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
    {
        newAvgFreq += possibleTags[i].second;
    }
    newAvgFreq = newAvgFreq / possibleTags.size() + 1;

    for (vectorIter = possibleTags.end() - 1; vectorIter != possibleTags.begin();
         --vectorIter)
    {
<<<<<<< HEAD
        vector<CPair<CTag, CPair<int, int>>> possibleBegin = vectorIter->first;
        for (vector<CPair<vector<CPair<CTag, CPair<int, int>>>, unsigned int>>::iterator it = vectorIter - 1;; --it)
        {
            vector<CPair<CTag, CPair<int, int>>> possibleEnd = it->first;
            vector<CPair<CTag, CPair<int, int>>>::iterator ite = pStrStr(m_VtagFileData, possibleBegin);
            unsigned int beg = ite->second.first;
            ite = pStrStr(m_VtagFileData, possibleEnd);
            unsigned int end = ite->second.second;
            if (beg - end < m_fileData.size() / m_minSz || end - beg < m_fileData.size() / m_minSz)
=======
        vector<CTagDescription> possibleBegin = vectorIter->first;
        for (vector<pair<vector<CTagDescription>, UINT>>::iterator it = vectorIter - 1;; --it)
        {
            vector<CTagDescription> possibleEnd = it->first;
            vector<CTagDescription>::iterator ite = pStrStr(m_mod, possibleBegin);
            UINT beg = ite->nTagBegin;
            ite = pStrStr(m_mod, possibleEnd);
            UINT end = ite->nTagEnd;
            if (beg - end < m_fileData.size() / m_unMinSz || end - beg < m_fileData.size() / m_unMinSz)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
            {
                if (beg > end)
                {
                    m_newsBegin = possibleEnd;
                    m_newsEnd = possibleBegin;
                    string news(m_fileData, end, beg - end);
                    if (news.size() > 0.01 * m_fileData.size() && news.size() < 0.2 * m_fileData.size())
                    {
                        return;
                    }
                }
                else
                {
                    m_newsBegin = possibleBegin;
                    m_newsEnd = possibleEnd;
                    string news(m_fileData, beg, end - beg);
                    if (news.size() > 0.01 * m_fileData.size() && news.size() < 0.2 * m_fileData.size())
                    {
                        return;
                    }

                }
            }
            if (it == possibleTags.begin())
                break; 
        }
    }
}

<<<<<<< HEAD
void CNewsFinder::writeNews()
{
    unsigned int offset = 0;
    m_fileOut << "<head>\n";
    if (m_newsEnd.empty())
        return;
    // Получаем строчку новости и выводим её
    while (1)
    {
        string res = getNews(m_newsBegin, m_newsEnd, offset);
        if (res.empty())
            break;
        m_fileOut << res;
        m_fileOut << "\n<div>####################################################################";
        m_fileOut << "#######################################################################</div>\n";
    }
    m_fileOut << "</head>\n";
}

//#################################  PRIVATE SECTION  #####################################

void CNewsFinder::removeTags(vector<std::string> &tagsToRemove)
=======
VOID CNewsFinder::WriteNews(LPCSTR lpcszOutFileName)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
{
    ///< Выходной файл.
    std::fstream fileOut(lpcszOutFileName, ios::out);

    fileOut << "<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"></head>\n"
    "<body>\n";

    UINT offset = 0;
    // Получаем строчку новости и выводим её
    for(;;)
    {
        string res = getNews(m_newsBegin, m_newsEnd, offset);
        if (res.empty())
            break;
        fileOut << res;
        fileOut << "\n#########################################################################################\n";
    }
    fileOut << "\n</body></html>";
}

//#################################  PRIVATE SECTION  #####################################

VOID CNewsFinder::removeTags(vector<std::string> &tagsToRemove)
{
    UINT i = 0;
    UINT j = 0;
    if (tagsToRemove.size() == 0)
        return;

<<<<<<< HEAD

    // проходим по всем тегам
    for (i = 0; i < m_VtagFileData.size(); ++i)
=======
    // M.A.P. очень грубо реализован механизм вычистки тегов
    // 1. поиск перебором 2. многократный персчет кода

    // проходим по всем тегам
    for (i = 0; i < m_mod.size(); ++i)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
    {
        // проходим по всему массиву тегов для удаления
        for (j = 0; j < tagsToRemove.size(); ++j)
        {
            // если тег совпал с тегом для удаления, то стираем его
<<<<<<< HEAD
            if (getTagCode(tagsToRemove[j]) == m_VtagFileData[i].first.tag)
            {
                m_VtagFileData.erase(m_VtagFileData.begin() + i);
=======
            if (getTagCode(tagsToRemove[j]) == m_mod[i].nTagCode)
            {
                m_mod.erase(m_mod.begin() + i);
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
                break;
            }
        }
    }
}

<<<<<<< HEAD
void CNewsFinder::removeTags(vector< std::pair<std::string, std::string> > &tagsToRemove)
=======
VOID CNewsFinder::removeTags(vector< std::pair<std::string, std::string> > &tagsToRemove)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
{
    UINT i = 0;
    UINT j = 0;

    // M.A.P. очень грубо реализован механизм вычистки тегов 
    // 1. поиск перебором 2. многократный персчет кода

    // проходим по всем тегам
<<<<<<< HEAD
    for (i = 0; i < m_VtagFileData.size(); ++i)
=======
    for (i = 0; i < m_mod.size(); ++i)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
    {
        // проходим по всему массиву тегов для удаления
        for (j = 0; j < tagsToRemove.size(); ++j)
        {
            // если тег совпал с тегом для удаления
<<<<<<< HEAD
            if (getTagCode(tagsToRemove[j].first) == m_VtagFileData[i].first.tag)
            {
                // стираем тег
                m_VtagFileData.erase(m_VtagFileData.begin() + i);
                // пока не получим закрывающий тег
                while (getTagCode(tagsToRemove[j].second) != m_VtagFileData[i].first.tag)
                {
                    m_VtagFileData.erase(m_VtagFileData.begin() + i);
                }
                m_VtagFileData.erase(m_VtagFileData.begin() + i);
=======
            if (getTagCode(tagsToRemove[j].first) == m_mod[i].nTagCode)
            {
                // стираем тег
                m_mod.erase(m_mod.begin() + i);
                // пока не получим закрывающий тег
                while (getTagCode(tagsToRemove[j].second) != m_mod[i].nTagCode)
                {
                    m_mod.erase(m_mod.begin() + i);
                }
                m_mod.erase(m_mod.begin() + i);
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
                --i;
                // идем к следующему тегу
                break;
            }
        }
    }
}

unsigned short CNewsFinder::getTagCode(const string &tag)
{
    unsigned short code = 0;
<<<<<<< HEAD
    for (unsigned int i = 0; i < tag.size(); ++i)
=======
    for (UINT i = 0; i < tag.size(); ++i)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
    {
        code += tag[i];
    }
    return code;
}

<<<<<<< HEAD
CTriple<CTag, CPair<int, int>, string> CNewsFinder::getNextTag()
{
    CTag tagCode(0,0);
    CTriple<CTag, CPair<int, int>, string> reti;
    string tag;
    CPair<int, int> tagPosition(-1,-1);

    while (currFileDataPos != m_fileData.size())
    {
        // если (возможно) открывающий тег
        if (m_fileData[currFileDataPos] == '<')
        {
            // к примеру, знак < в js
            if (tagPosition.first != -1)
            {
                tagPosition.first = currFileDataPos;
                ++currFileDataPos;
            }
            else
                tagPosition.first = currFileDataPos;

            // пока не дойдем до пробела/закрывающей скобки - записываем
            while (m_fileData[currFileDataPos] != ' ' && m_fileData[currFileDataPos] != '>')
            {
                tag += m_fileData[currFileDataPos];
                tagCode.tag += m_fileData[currFileDataPos];
                ++currFileDataPos;				
            }
        }
        // если закрывающая скобка - записываем
        if (m_fileData[currFileDataPos] == '>')
        {
            tag += m_fileData[currFileDataPos];
            //LowerCase(&tag);
            tagCode.tag += m_fileData[currFileDataPos];
            tagPosition.second = currFileDataPos;

            if(tag[1] == '/')
                tagCode.isClose = 1;
            ++currFileDataPos;
            reti.first = tagCode;
            reti.second = tagPosition;
            reti.third = tag;
            return reti;
        }
        ++currFileDataPos;
    }
    return CTriple<CTag, CPair<int, int>, string>(CTag(-1, -1), CPair<int, int>(-1, -1), "");
=======
CTagDescription CNewsFinder::getNextTag()
{
    CTagDescription tagCode;
    tagCode.bIsClose = 0;
    tagCode.nTagCode = -1;
    tagCode.nTagBegin = -1;
    tagCode.nTagEnd = -1;
    string tag;

    for(; m_unCurrFileDataPos != m_fileData.size(); ++m_unCurrFileDataPos)
    {
        // если (возможно) открывающий тег
        if (m_fileData[m_unCurrFileDataPos] == '<')
        {
            // M.A.P. как данная проверка согласуется со стандартом html?
            // к примеру, знак < в js
            if (tagCode.nTagBegin != -1)
                ++m_unCurrFileDataPos;
            else
                tagCode.nTagBegin = m_unCurrFileDataPos;

            // пока не дойдем до пробела/закрывающей скобки - записываем
            while (m_fileData[m_unCurrFileDataPos] != ' ' && m_fileData[m_unCurrFileDataPos] != '>')
            {
                tag += m_fileData[m_unCurrFileDataPos];
                tagCode.nTagCode += m_fileData[m_unCurrFileDataPos];
                ++m_unCurrFileDataPos;				
            }
        }
        // если закрывающая скобка - записываем
        if (m_fileData[m_unCurrFileDataPos] == '>' && tagCode.nTagBegin != -1)
        {
            tag += m_fileData[m_unCurrFileDataPos];
            tagCode.nTagCode += m_fileData[m_unCurrFileDataPos];
            tagCode.nTagEnd = m_unCurrFileDataPos;

            if(tag[1] == '/')
                tagCode.bIsClose = 1;
            else
                tagCode.bIsClose = 0;
#ifdef _DEBUG
            if (plpszTagTable[tagCode.nTagCode] == NULL)
            {
                plpszTagTable[tagCode.nTagCode] = (LPTSTR)tag.c_str();
            }
#endif
            return tagCode;
        }
    }

    return tagCode;
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
}

int CNewsFinder::checksum(const vector<CTagDescription> &src)
{
<<<<<<< HEAD
    unsigned int cnt = 0;

    for (unsigned int i = 0; i < src.size(); ++i)
        // если тег закрывающий.
        if (src[i].first.isClose == 1)
=======
    UINT cnt = 0;

    for (UINT i = 0; i < src.size(); ++i)
    {
        // если тег закрывающий.
        if (src[i].bIsClose == 1)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
            ++cnt;
    }
    // если закрывающих тегов больше, чем открывающих - возвратим 0
    if (cnt > src.size() / 2 + 1) // M.A.P. загадочная формула
        return 0;

    return 1;
}

// M.A.P. ничего не говорящее название фукнции
int CNewsFinder::checkWordTruePairs(const vector<CTagDescription> &src)
{
    UINT i;
    stack<CTagDescription> st;

    for(i = 0; i < src.size(); ++i)
    {
        // если он - открывающий - положим в стек
        if (src[i].bIsClose == 0)
            st.push(src[i]);
        else
        {
            // если стек пуст - закрывающему тегу нет открывающего.
            if (st.empty())
                return 0;
            // пока не получим открывающий для текущего тега, извлекаем
            // теги из стека и проверяем их
            while (st.top().nTagCode + '/' != src[i].nTagCode) // M.A.P. загадочная проверка. Зачем код " + '/'"?
            {
                st.pop();
                if (st.empty())
                    return 0;
            }
            st.pop();
        }
    }
    return 1;
}

<<<<<<< HEAD
int CNewsFinder::getStringFreq(const vector<CPair<CTag, CPair<int, int>>> &str,
                               unsigned int pos)
=======
int CNewsFinder::getStringFreq(const vector<CTagDescription> &str,
                               UINT unPos)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
{
    UINT freq = 0;
    UINT i = 0;
    UINT j = 0;

    for (i = 0; i < m_unTableSize; ++i)
    {
        if (m_pTable[i][unPos] != 0)
        {
<<<<<<< HEAD
            unsigned int temp = i;
            while (j < str.size() && temp < m_tableSize && m_pTable[temp][pos + j] != 0)
=======
            UINT temp = i;
            while (j < str.size() && temp < m_unTableSize && m_pTable[temp][unPos + j] != 0)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
            {
                ++temp;
                ++j; 
            }
            if (j == str.size())
                ++freq;
            j = 0;
        }
    }
    return freq;
}

<<<<<<< HEAD
int CNewsFinder::getTagSubs(const vector<CPair<CTag, CPair<int, int>>> &src, int pos)
=======
int CNewsFinder::getTagSubs(const vector<CTagDescription> &src, int nPos)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
{
    // выбираем две подстроки длины на 1 меньше
    vector<CTagDescription> first(src.begin(), src.end() - 1);
    vector<CTagDescription> second(src.begin() + 1 ,src.end());
    set <vector<CTagDescription>, tagcodecpr>::iterator setIter;
    int flag = 0;

    if (first.size() < m_unMinSz)
        return 1;

    if (first.size() == m_unMinSz)
    {
        setIter = m_subsArr.find(first);
        if (setIter == m_subsArr.end())
        {
            m_subsArr.insert(first);
            if (checksum(first) && checkWordTruePairs(first))
            {
<<<<<<< HEAD
                unsigned int strFreq = getStringFreq(first, pos);
                if (strFreq >= m_minFreq)
=======
                UINT strFreq = getStringFreq(first, nPos);
                if (strFreq >= m_unMinFreq)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
                {
                    m_freq.insert(make_pair(first, strFreq));
                    m_unAvgLen += first.size();
                    m_unAvgFreq += strFreq;
                }
                else
                    flag = 1;
            }
        }
        setIter = m_subsArr.find(second);
        if (setIter == m_subsArr.end())
        {
            m_subsArr.insert(second);
            if (checksum(second) && checkWordTruePairs(second))
            {
<<<<<<< HEAD
                unsigned int strFreq = getStringFreq(second, pos + 1);
                if (strFreq >= m_minFreq)
=======
                UINT strFreq = getStringFreq(second, nPos + 1);
                if (strFreq >= m_unMinFreq)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
                {
                    m_freq.insert(make_pair(second, strFreq));
                    m_unAvgLen += second.size();
                    m_unAvgFreq += strFreq;
                }
                else
                    flag = 1;
            }
        }
        if (flag)
            return 0;
        return 1;
    }

    setIter = m_subsArr.find(src);
    if (setIter == m_subsArr.end())
    {
        m_subsArr.insert(src);
        if (getTagSubs(first, nPos) != 0 && getTagSubs(second, nPos + 1) != 0)
        {
            if (checksum(src) && checkWordTruePairs(src))
            {
<<<<<<< HEAD
                unsigned int strFreq = getStringFreq(src, pos);
                if (strFreq < m_minFreq)
=======
                UINT strFreq = getStringFreq(src, nPos);
                if (strFreq < m_unMinFreq)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
                    return 0;
                m_freq.insert(make_pair(src, strFreq));
                m_unAvgLen += src.size();
                m_unAvgFreq += strFreq;
            }
        }
        else
            return 0;
    }
<<<<<<< HEAD

    return 1;
}

string CNewsFinder::getNews(vector<CPair<CTag, CPair<int, int>>> &newsBegin,
                            vector<CPair<CTag, CPair<int, int>>> &newsEnd,
                            unsigned int &offset)
=======
    return 1;
}

string CNewsFinder::getNews(vector<CTagDescription> &newsBegin,
                            vector<CTagDescription> &newsEnd,
                            UINT &unOffset)
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
{
    UINT i = 0;
    // Ищем позицию, с которой начинается новость
<<<<<<< HEAD
    //int begin = newsBegin[0].second.first;
    vector<CPair<CTag, CPair<int, int>>>::iterator it = pStrStr(m_VtagFileData, newsBegin, offset);
    if (it == m_VtagFileData.end())
    {
        return string("");
    }
    int begin = it->second.first;
    offset = it - m_VtagFileData.begin() + 1;
    // Позиция, на которой новость заканчивается
    it = pStrStr(m_VtagFileData, newsEnd, offset);
    if (it == m_VtagFileData.end())
    {
        return string("");
    }
    int end = it->second.second;
    offset = it - m_VtagFileData.begin() + 1;
=======
    vector<CTagDescription>::iterator it = pStrStr(m_mod, newsBegin, unOffset);
    if (it == m_mod.end())
    {
        return string("");
    }
    int begin = it->nTagBegin;
    unOffset = it - m_mod.begin() + 1;
    // Позиция, на которой новость заканчивается
    it = pStrStr(m_mod, newsEnd, unOffset);
    if (it == m_mod.end())
    {
        return string("");
    }
    int end = it->nTagEnd;
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
    // номер тега, с которого новость начинается и заканчивается, в modifiedTagPosition
    string ret(m_fileData, begin, end - begin);
    return ret;
}
<<<<<<< HEAD

void CNewsFinder::printTable()
{
    for (unsigned int i = 0; i < m_tableSize; ++i)
    {
        for (unsigned int j = 0; j < m_tableSize; ++j)
        {
            std::cout << m_pTable[i][j] << " ";
        }
        std::cout << "\n";
    }
}
=======

long CNewsFinder::GetlastError()
{
    return m_lLastError;
}

//#################################  DEBUG SECTION  #####################################

#ifdef _DEBUG

    VOID CNewsFinder::dbgPrintData(VOID)
    {
         vector<CTagDescription>::iterator it = m_mod.begin();
         for(; it != m_mod.end(); ++it)
         {
             string word(m_fileData, it->nTagBegin, it->nTagEnd - it->nTagBegin + 1);
             DebugPrint("%s", (LPTSTR)word.c_str());
         }
    }

    VOID CNewsFinder::printTable()
    {
        for (UINT i = 0; i < m_unTableSize; ++i)
        {
            for (UINT j = 0; j < m_unTableSize; ++j)
            {
                std::cout << m_pTable[i][j] << " ";
            }
            std::cout << "\n";
        }
    }

    string CNewsFinder::getTagWord(vector<CTagDescription> &tagSeq)
    {
        string reti;
        for(UINT i = 0; i < tagSeq.size(); ++i)
            reti += plpszTagTable[tagSeq[i].nTagCode];
        return reti;
    }

#endif
>>>>>>> c3932ccb754fbf66223917f47d690a8492335d51
